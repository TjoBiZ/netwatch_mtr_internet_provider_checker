Технический Prompt (само-задание скрипта)
	1.	Ввод цели: спросить или принять аргументом IPv4/хост (например, 8.8.8.8).
	2.	Только mtr: каждые ~1 сек запускать mtr -r -w -n -c 1 -i 1 <target>. Блок выводить в консоль и писать в «полный лог» текущей эпохи.
	3.	Рабочая папка запуска: netwatch_run_<target>_<TS>/. Внутри:
	•	mtr_full_epoch_<N>.log — полный mtr за эпоху;
	•	mtr_events_lost.log — только периоды потерь (ежесекундные блоки) + строки OK interval: …;
	•	mtr_route_flaps.log — записи лишь тогда, когда смена маршрута совпала с падением цели >2с (в момент смены или в течение 5с после);
	•	target_ping.log — непрерывный системный ping до цели;
	•	hop_pings/<IP>.txt — непрерывные ping по доступным IP-хопам (не ???, не сама цель);
	•	summary.csv — построчная сводка раз в секунду;
	•	agg_per_hop.csv — агрегат по каждому IP-хопу (см. п.6);
	•	loss_episodes.csv — эпизоды недоступности цели с деталями (см. п.7);
	•	route_changes.csv — CSV-журнал смен маршрута;
	•	INDEX.md — короткий индекс файлами.
	4.	Базовые “дыры”: в первом снимке эпохи собрать индексы с ??? и исключить их из детекции потерь и решений о ротации в пределах эпохи.
	5.	Ротация (debounce): переход в новую эпоху только если нормализованная сигнатура (на исключённых индексах всегда ???) держится ≥3 подряд снимка и прошло ≥60с с предыдущей ротации.
	6.	Аксиома учёта потерь:
	•	Потери на промежуточных хопах учитываются только когда цель сейчас не отвечает (по системному ping).
	•	Вести агрегат по IP-хопам:
loss_seconds_when_target_down (сколько секунд наблюдался loss>0 на хопе во время «цель не отвечает»),
first_fault_events (сколько раз этот хоп был первым проблемным в секунде, когда цель не отвечала).
	7.	Эпизоды падения цели: когда цель переходит OK → DOWN, создать эпизод; когда DOWN → OK — закрыть эпизод и записать строку в loss_episodes.csv:
start, end, duration_s, first_fault_hop_idx, first_fault_ip, prev_ip_before_fault, route_changes_in_episode, norm_sig_start, norm_sig_end.
	8.	Первые виновники: в каждой секунде «цель DOWN» находить самый ранний (минимальный индекс) хоп, где (loss>0 или host=='???' у не исключённого индекса). Его и считать «первым виновником». В loss_episodes.csv писать ещё и prev_ip_before_fault — IP с предыдущего хопа (если есть).
	9.	Маршрут ↔ цель: вести route_changes.csv (время, старая/новая нормализованные сигнатуры, epoch_before→epoch_after) и считать route_changes_in_episode для текущего эпизода. В mtr_route_flaps.log писать только коррелированные (см. п.3).
	10.	Системные утилиты: только mtr и системный ping (Linux/macOS), опционально gawk для таймштампов.
	11.	Привилегии: если mtr требует root (raw sockets), автоперезапустить скрипт через sudo (чтобы можно было ввести пароль).
	12.	Завершение: по Ctrl+C корректно остановить все подпроцессы и дописать агрегаты.
	13.	History creating mtr script - tester internet provider - https://chatgpt.com/share/68aa3e48-68c8-8009-a30e-29dbb26392be
