Goal
Build a cross-platform (Ubuntu/macOS) diagnostic tool that continuously monitors end-to-end connectivity using mtr + OS ping, writes clean logs, and produces concise CSV summaries suitable for an ISP (Xfinity) escalation.

Musts
1) Use only system tools: mtr and ping. (gawk optional; if absent, add timestamps in Python.)
2) One main target (e.g., 8.8.8.8). Additionally allow a comma-separated list of extra IPs to ping in parallel with OS ping only (no mtr). Recommendation for users: include WAN IP, WAN Default Gateway, and DNS servers from the router UI.
3) mtr snapshot cadence = 1 sec (1 probe per hop per second). If mtr requires privileges, auto-reexec via sudo and prompt for the user’s password.
4) Baseline exclusions: at start, any “???” hops present are permanently excluded from loss accounting until the route changes.
5) Loss axiom: count loss on intermediate hops ONLY if the final target is DOWN at that second.
6) Loss logging: 
   - `mtr_events_lost.log` contains ONLY snapshots/blocks when loss is detected (per second) on any non-excluded hop.
   - `loss_episodes.csv` records contiguous target-down episodes with start/end/duration, first faulty hop, previous hop, route signatures and whether the route changed during the episode; also record which extra IPs were UP/DOWN at the episode start.
7) Route changes: form a normalized route signature (index:IP, with excluded “???”). If signature is different for 3 consecutive snapshots and at least 60s passed since last rotation, start a new epoch (files continue under the same run folder but `mtr_full_epoch_N.log` increases). Log changes to `route_changes.csv`.
8) Continuous pings:
   - Run OS `ping -i 1` to the main target (stateful classification UP/DOWN) -> `target_ping.log`.
   - For each visible IP hop (except “???” and the final target), create a subfile `hop_pings/<IP>.txt` with continuous ping and timestamps.
   - For each user-provided extra IP, ping continuously -> `extra_pings/<IP>.log`.
9) Files to produce inside `netwatch_run_<target>_<timestamp>/`:
   - `mtr_full_epoch_N.log` (per-second blocks), `mtr_events_lost.log` (loss only),
     `mtr_route_flaps.log` (route change while target was DOWN >2s),
     `summary.csv` (one row per second with route signature and loss lists),
     `agg_per_hop.csv` (loss seconds & first-fault counters per hop, counted only when target was DOWN),
     `loss_episodes.csv`, `route_changes.csv`,
     `target_ping.log`, `hop_pings/<IP>.txt`, `extra_pings/<IP>.log`, `INDEX.md`.
10) Extras status: every second write `extras_status.csv` → `timestamp,target_down,<extra1>,<extra2>...` as `UP/DOWN`.
11) Route change bursts: if the route changes while the target is DOWN for >2s, append a human line to `mtr_route_flaps.log`.
12) Performance & safety:
    - Write streams line-by-line (no buffering in memory).
    - Limit hop pingers to 32 concurrent files.
13) Clean shutdown on Ctrl+C: stop all pingers, flush aggregations, print the run folder path.

Non-goals
- No third-party Python packages, no GUI, no network modifications.

Deliverables
- `netwatch_mtr_ru.py` (Russian), `netwatch_mtr_en.py` (English), `README.md` (EN primary + RU section), `.gitignore`.


Технический Prompt (само-задание скрипта)
	1.	Ввод цели: спросить или принять аргументом IPv4/хост (например, 8.8.8.8).
	2.	Только mtr: каждые ~1 сек запускать mtr -r -w -n -c 1 -i 1 <target>. Блок выводить в консоль и писать в «полный лог» текущей эпохи.
	3.	Рабочая папка запуска: netwatch_run_<target>_<TS>/. Внутри:
	•	mtr_full_epoch_<N>.log — полный mtr за эпоху;
	•	mtr_events_lost.log — только периоды потерь (ежесекундные блоки) + строки OK interval: …;
	•	mtr_route_flaps.log — записи лишь тогда, когда смена маршрута совпала с падением цели >2с (в момент смены или в течение 5с после);
	•	target_ping.log — непрерывный системный ping до цели;
	•	hop_pings/<IP>.txt — непрерывные ping по доступным IP-хопам (не ???, не сама цель);
	•	summary.csv — построчная сводка раз в секунду;
	•	agg_per_hop.csv — агрегат по каждому IP-хопу (см. п.6);
	•	loss_episodes.csv — эпизоды недоступности цели с деталями (см. п.7);
	•	route_changes.csv — CSV-журнал смен маршрута;
	•	INDEX.md — короткий индекс файлами.
	4.	Базовые “дыры”: в первом снимке эпохи собрать индексы с ??? и исключить их из детекции потерь и решений о ротации в пределах эпохи.
	5.	Ротация (debounce): переход в новую эпоху только если нормализованная сигнатура (на исключённых индексах всегда ???) держится ≥3 подряд снимка и прошло ≥60с с предыдущей ротации.
	6.	Аксиома учёта потерь:
	•	Потери на промежуточных хопах учитываются только когда цель сейчас не отвечает (по системному ping).
	•	Вести агрегат по IP-хопам:
loss_seconds_when_target_down (сколько секунд наблюдался loss>0 на хопе во время «цель не отвечает»),
first_fault_events (сколько раз этот хоп был первым проблемным в секунде, когда цель не отвечала).
	7.	Эпизоды падения цели: когда цель переходит OK → DOWN, создать эпизод; когда DOWN → OK — закрыть эпизод и записать строку в loss_episodes.csv:
start, end, duration_s, first_fault_hop_idx, first_fault_ip, prev_ip_before_fault, route_changes_in_episode, norm_sig_start, norm_sig_end.
	8.	Первые виновники: в каждой секунде «цель DOWN» находить самый ранний (минимальный индекс) хоп, где (loss>0 или host=='???' у не исключённого индекса). Его и считать «первым виновником». В loss_episodes.csv писать ещё и prev_ip_before_fault — IP с предыдущего хопа (если есть).
	9.	Маршрут ↔ цель: вести route_changes.csv (время, старая/новая нормализованные сигнатуры, epoch_before→epoch_after) и считать route_changes_in_episode для текущего эпизода. В mtr_route_flaps.log писать только коррелированные (см. п.3).
	10.	Системные утилиты: только mtr и системный ping (Linux/macOS), опционально gawk для таймштампов.
	11.	Привилегии: если mtr требует root (raw sockets), автоперезапустить скрипт через sudo (чтобы можно было ввести пароль).
	12.	Завершение: по Ctrl+C корректно остановить все подпроцессы и дописать агрегаты.
	13.	History creating mtr script - tester internet provider - https://chatgpt.com/share/68aa3e48-68c8-8009-a30e-29dbb26392be
